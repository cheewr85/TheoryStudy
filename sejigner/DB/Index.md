# Index
데이터베이스 테이블의 검색 속도를 향상시키기 위해 저장 공간에 생성하는 자료구조

![index](/sejigner/img/db/index/1.png)

데이터를 조회하기만 하는 SELECT 키워드 외에도 조회가 동반되는 UPDATE와 DELETE의 성능 모두 향상된다.

인덱스가 없으면 조회 시 Full Scan 해야 하기 때문에 처리 속도가 느리다.

### 인덱스의 관리
DBMS가 빠르게 원하는 값을 조회하려면 인덱스가 항상 최신 상태로 정렬되어 있어야 한다. 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE 등으로 변동이 생기면 인덱스 역시 변경이 필요하기 때문에 오버헤드가 발생한다.

## 인덱스의 장점과 단점
- 장점
	- 테이블 조회 속도와 UPDATE, DELETE의 속도를 향상시킨다.
	- 전반적인 시스템의 부하를 줄인다.
-  단점
	- 인덱스를 사용하면 DB의 약 10%에 달하는 저장 공간이 사용된다.
	- 인덱스의 관리에 리소스가 투입되므로 잘못 사용하면 오히려 성능에 악영향을 준다.

UPDATE와 DELETE의 경우 인덱스는 삭제되지 않고, '사용하지 않음' 처리가 되는데, 이 키워드가 자주 사용되면 인덱스가 실제 데이터에 비해 지나치게 비대해져 성능이 저하될 수 있다. 따라서 다음과 같은 경우가 아니면, 사용에 주의해야 한다.

- 규모가 작지 않은 테이블
- 외래키가 사용되는 컬럼
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 테이블
- JOIN, WHERE, ORDER BY에 의해 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼

## 인덱스의 자료구조
- 해시 테이블 (Hash Table)
	- 빠른 데이터 검색에 유용함
	- Key 값을 이용해 고유한 Index를 생성하고, 그 데이터가 실제로 위치한 주소가 Value가 됨
	- 해시 구조는 등호 연산에만 특화되었기 때문에 부등호 연산이 자주 사용되는 DB 검색에서는 적합하지 않음
	- 즉, 어떤 특정 데이터가 포함된 데이터를 검색하기 위한 쿼리에는 해시가 도움이 되지 않음

- B+Tree
	- 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조
	- 리프노드(데이터 노드)만 인덱스+데이터(Value) 구조이고, 나머지 인덱스 노드는 Key값만 보유
	- 리프노드 간은 LinkedList로 연결
	- 데이터 노드 크기는 인덱스 노드 크기와 다를 수 있음

![b+tree](/sejigner/img/db/index/2.png)
