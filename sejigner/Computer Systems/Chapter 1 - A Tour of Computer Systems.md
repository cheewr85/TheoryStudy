# Chapter 1: A Tour of Computer Systems

## 1.4 프로세서는 메모리에 저장된 지시를 읽고 해석한다.

### Shell

- 커맨드라인 인터프리터로, 운영체제에서 사용자에게 보내는 메시지인 프롬프트를 출력하고, 사용자가 커맨드 라인을 입력하는 것을 기다리며, 명령을 수행한다.

- 커맨드라인에 입력된 첫 단어가 내장된 명령어가 아니라면 실행가능한 파일의 이름으로 간주하여 로드 후 실행한다. 

### 시스템의 하드웨어 조직

[!Hardware Organization](img/systems 1.4/1.png)

- bus
  전기도관 사이를 왔다갔다하며 정해진 크기의 워드(word)를 옮긴다.
  워드는 바이트를 담고 있는데, 워드 당 보통 4 바이트나 8 바이트를 갖는다.

- I/O 디바이스
  입출력 디바이스는 외부와의 연결을 담당하는데 위 예시의 사례에서는 총 4개의 디바이스를 갖는다; 사용자의 입력을 위한 키보드와 마우스 그리고 추력을 위한 디스플레이, 데이터와 프로그램의 장기 저장을 위한 디스크 드라이브
  각각의 I/O 디바이스는 컨트롤러 또는 어댑터를 이용하여 I/O 버스와 정보를 주고 받는다.
  
  - 컨트롤러 : 디바이스 그 자체의 칩셋 또는 마더 보드로 불리는 회로 보드 위의 칩셋
  
  - 어댑터 : 마더보드의 슬롯에 장착되는 일종의 카드

- Main Memory
  임시 저장 장치로 프로세서가 프로그램을 실행하는 동안에 프로그램과 그것이 취급하는 데이터를 보관한다. 물리적으로는, 메인 메모리는 Dynamic Random Access Memory 라는 DRAM 칩의 집합체로 구성되어 있고, 논리구조로 보면, 메모리는 0부터 시작하는 주소값(배열 인덱스)을 갖는 일련의 바이트 배열로 구성되어 있다.
  일반적으로 기계어 명령은 타입에 따라 다른 바이트 갯수, 즉 사이즈를 갖는다. (C언어 short 2 bytes, int/float 4 bytes, long/double 8 bytes )

- Processor
  중앙처리장치(CPU)로도 부르며, 메인 메모리에 저장된 명령어를 해석하는 엔진 역할을 한다. 코어에는 program counter(PC)로 불리는 워드 사이즈의 저장장치(레지스터)가 있다. PC는 메인 메모리 속 기계어 명령의 주소를 참조한다.
  전원이 켜지고 종료될 때까지 PC가 명령어를 가리키는 작업을 반복한다. 프로세서는 주어진 명령을 수행하고, PC가 다음 명령을 참조하도록 한다.
  프로세서는 명령어에 따라 다음의 단순한 작업을 수행하는데, 메인 메모리, 레지스터 파일, arithmetic/logic unit(산술논리 연산장치)를 거친다.
  
  - Load : 메인 메모리에서 바이트나 워드를 레지스터로 복제한다. 레지스터 기존 내용물은 덮어씌워진다.
  
  - Store : 레지스터에서 바이트나 워드를 복사해서 메인 메모리의 한 위치에 저장한다. 그 위치에 기존 내용물은 덮어씌워진다.
  
  - Operate : 두 레지스터의 내용물들을 ALU에 복사하고, 두 워드에서 산술 작업을 수행하며 Program counter의 이전 값들을 덮어씌운다.
  
  - Jump : 명령으로부터 워드를 추출하고 PC에 워드를 복사한다. PC의 이전 값은 덮어씌워진다.

## 1.5 캐시의 중요성

- 큰 저장 장치는 작은 저장장치보다 느리다.

- 메인 메모리가 수십억개의 파일을 저장하는것과 달리 레지스터 파일들은 몇 백 바이트의 정보만 저장이 가능하다.

- 프로세서는 메인 메모리보다 레지스터 파일에서 거의 100배 가까이 빨리 읽을 수 있다. 

- 프로세서가 더 빨라지도록 하는 것이 메인 메모리가 빨라지도록 하는 것보다 훨씬 쉽고 저렴하다. -> 프로세서 - 메모리 격차가 벌어지게 되었다.

- 그 격차를 해소하기 위해, 캐시 메모리가 도입되었다. 프로세서가 미래에 필요로 할 것으로 예상되는 정보를 임시로 저장하고 있는 공간으로 사용된다.

[!Memory Hierarchy](img/systems 1.4/2.png)

- 프로세서 칩에 있는 L1 캐시는 수만 바이트를 지니고 고, 레지스터 파일만큼 빠르게 접근 가능하다.

- 그보다 더 큰 L2 캐시는 수십,수백만 바이트를 지니며 특별한 버스가 프로세서와 연결해준다. L1 캐시보다 5배 정도 속도가 느리지만 메인 메모리보다 5, 10배 정도 빠르다.

- Static Random Access Memory (SRAM)이라는 하드웨어 기술로 구현되었다.

- 새롭고 더 좋은 시스템도 L1, L2, L3 3단 구조는 항상 포함한다.

- 캐시는 큰 메모리 사이즈와 빠른 속도 둘 다를 다음을 통해 확보할 수 있었다.
  
  - Locality
    프로그램이 데이터와 코드를 localize된 지역에서 접근한다.

## 1.6 시스템 계층 속 저장 장치

- 계층 구조에서 내려올 수록 용량은 커지고 속도는 느려진다.

- 어떤 레벨에서 저장장치가 더 낮은 수준의 저장장치에게는 캐시의 역할을 한다.

- 즉, 레지스터 파일은 L1 캐시에게 캐시이고, L1 캐시는 L2 캐시의 캐시, L3 캐시는 메인 메모리의 캐시 역할을 한다.

## 1.7 운영체제가 하드웨어를 관리한다.

[!Layered view of a computer system](img/systems 1.4/3.png)

- 프로그램이 실행되고, 키보드, 디스플레이, 디스크, 메인 메모리 등이 사용될 때, 프로그램이 직접 접촉하지 않고, 운영체제가 제공하는 서비스를 통해서 접근한다.

- 응용프로그램은 하드웨어를 조작하기 위해 반드시 운영체제를 거쳐야 한다. 이는 다음과 같은 목적을 갖는다.
  
  - 악성프로그램으로부터 하드웨어를 보호
  
  - 앱에 단순하고 통일성 있는 메커니즘을 제공, 저수준 하드웨어 장치는 복잡하고 프로그램이 돌아가는 방식과 다르기 때문

### 운영체제의 추상화

#### Process

- 실행 중인 프로그램을 위한 운영체제의 추상화이다.

- 여러개의 프로세스가 같은 시스템에서 concurrent하게 동작할 수 있다.

- 프로세스를 동작시킬 CPU보다 프로세스 갯수가 더 많은 경우가 일반적이다.

- 전통적인 시스템은 한번에 하나의 프로그램만 동작시킬 수 있었지만, 멀티코어 프로세서는 여러가지 프로그램을 동시에 실행한다.

- 단일 CPU도 여러 프로세스를 동시에 실행할 수 있는 것으로 보이는데, 이는 프로세서가 여러 프로세스를 왔다갔다하기 때문이다.

- 운영체제는 프로세스가 실행을 위해 필요로 하는 상태 정보를 계속 추적한다.

- 이 상태는 Context라고도 불리는데, PC의 현재값, 레지스터 파일, 메인 메모리의 내용물 등을 포함한다.

- 유니프로세서는 단일 프로세스를 위한 코드만 수행할 수 있기 때문에 운영체제가 현 프로세스에서 다른 프로세스로 제어를 옮겨가려고 하면 현재 프로세스의 Context를 저장하고, 새로운 프로세스의 Context를 복원한 뒤, 새로운 프로세스에 제어를 넘긴다.

- 프로세스 간 전환은 메모리에 상주하는 **Kernel**이라는 운영체제 코드의 일부가 담당한다.

- 커널을 통한 프로세스 전환 과정
  
  1. 응용 프로그램이 운영체제에 특정한 행동을 요구하기 위해 시스템 콜이라고 불리는 명령어를 실행한다.
  
  2. 커널로 제어가 넘어간다.
  
  3. 커널이 요청된 작업을 수행하고 응용 프로그램으로 돌아온다.

- 커널은 분리된 프로세스가 아니라, 프로세스를 관리하기 위해 시스템이 사용하는 코드와 자료구조의 모음이다.

#### Thread

- 현대에 와서는 시스템은 실행 유닛인 쓰레드 여러개로 구성된다.

- 일반적으로 프로세스보다 더 효율적이고, 다중 프로세스 간 데이터 공유보다 스레드 간  공유가 더 용이하기 때문에 네트워크 서버에서의 Concurrency에 중요하다.

#### Virtual Memory

- 하나의 프로세스가 마치 메인 메모리를 독점적으로 사용하는 것처럼 보이게 하는 추상화이다. 

- Virtual address space - 특정 목적을 위한 영역으로 구성되어 있다.
  
  - 프로그램 코드와 데이터
    코드는 모든 프로세스에서 항상 고정된 주소값에서 시작한다. 코드와 데이터 영역은 실행가능한 오브젝트 파일의 내용물로부터 초기화된다.
  
  - Heap
    코드와 데이터 다음으로 런타임 힙이 뒤따른다. 프로세스가 시작되면 크기가 고정되는 코드와 데이터 영역과 달리 크기를 런타임에 동적으로 확장, 수축할 수 있다. 
  
  - Shared Libraries
    address 중간 부분에 공유된 라이브러리를 위한 코드와 데이터를 저장하는 공간이 있다. 
  
  - Stack
    사용자의 Virtual address space 맨위에 사용자 스택이 있는데 컴파일러가 함수 호출을 위해 사용한다. 힙처럼 스택도 동적으로 확장, 축소가 가능하다. 함수가 실행되면 확장되고 return에 축소된다.
  
  - Kernel virtual memory
    address space의 꼭대기를 차지한다. 응용프로그램은 이 영역의 내용물을 읽거나 쓸 수 없고, 커널 코드에 정의된 함수를 직접 호출할 수 없다. 프로그램이 접근하기 위해서는 커널이 작업을 하도록 해야 한다.

#### File

- 바이트 배열이다. 모든 입출력 장치는 파일의 형태로 구조화됐다.

- 다양한 입출력 장치를 통일된 형태로 볼 수 있게 해준다.

## 1.8 시스템은 네트워크를 통해 다른 시스템과 소통한다.

- 네트워크는 또 다른 입출력 장치로 볼 수 있다.

- 메인 메모리부터 네트워크 어댑터로 바이트의 배열을 복사하면, 데이터는 네트워크를 타고 다른 기계로 이동한다. 목적지가 로컬 디스크 드라이브가 아니라는 것이 기존 로컬 IO와의 차이이다.

- 네트워크의 핵심은 결국 정보를 다른 기계로 복사해주는 것이다.
