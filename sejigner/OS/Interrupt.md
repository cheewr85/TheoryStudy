# Interrupt
CPU가 프로그램을 실행하고 있을 때, 입출력 장치에서 예외상황이 발생하여 처리가 필요할 경우 CPU에 알려 처리하도록 한다. 입출력 연산이 오래 걸릴 경우 CPU 성능에 영향을 줄 수 있기 때문에 CPU는 입출력 연산이 지속하는 동안 다른 작업을 하다가 입출력 연산이 완료되면 신호를 받게 된다.

## 인터럽트의 구분
### 하드웨어 인터럽트
CPU가 아닌 다른 하드웨어 자치가 CPU에 어떤 사실을 알려주거나 CPU 서비스를 요청해야 할 경우 하드웨어가 발생시키는 인터럽트이다.

### 소프트웨어 인터럽트
소프트웨어가 발생시키는 인터럽트로, 소프트웨어에 인터럽트 라인이 세팅된다.

인터럽트가 필요할 때 소프트웨어나 하드웨어에 의해 CPU내에 인터셉트 라인이 세팅되면서 인터럽트가 발생된다.

## 인터럽트 과정
프로세스 X 실행 중 디스크 데이터 읽기 명령을 받았을 때,
1. 프로세스 X가 system call을 통해 인터럽트 발생
2. CPU가 진행 중인 기계어 코드 실행을 완료
3. 진행 상태(메모리 주소, 레지스터 값, 하드웨어 상태 등)를 프로세스의 PCB(Process Control Block)에 저장
4. PC에 다음에 실행할 명령의 주소를 저장
5. 인터럽트 벡터를 읽어서 얻은 ISR(Interrupt Service Routine) 주소값으로 점프하여 루틴 실행
	- 인터럽트 벡터 : 인터럽트가 발생할 때 처리해야 할 인터럽트 핸들러의 주소를 인터럽트 별로 보관하는 테이블
	- 인터럽트 서비스 루틴 : 인터럽트 핸들러라고도 하며, 운영체제 코드 영역에 인터럽트 별로 처리해야 할 내용이 저장되어 있음
6. 디스크 데이터 읽기
7. PCB에 저장된 레지스터를 복원
8. ISR 맨 끝 값의 IRET 명령이 인터럽트 해제
9. PC 값을 복원하여  이전 실행 위치로 복원

### 다른 예제
InteliJ에 입력하는 과정
1. 저장 경로 확인 후 로직 실행
2. 키보드 입력 인터럽트 발생
3. 현재 실행중인 프로세스 정보 저장 (Process Control Block)
4. 인터럽트 벡터에서 해당 ISR 찾기
5. 키보드 처리를 위한 ISR 주소로 변경
6. 키보드 인터럽트 처리
7. 저장된 저장 경로 확인 -> 복귀

## 특권 명령
### CPU가 수행하는 명령어의 종류
- 일반 명령 : 메모리에서 자료를 읽고, CPU에서 연산하는 등의 명령, 모든 프로그램이 수행할 수 있는 명령
- 특권 명령 : 장치, 타이머 등의 장치에 접근. 보안이 필요한 명령으로 운영체제만 접근 가능

### Kernel Mode vs User Mode
운영체제가 하드웨어 보안을 유지하기 위해 지원하는 두 가지 모드
- Kernel mode : 운영체제가 CPU의 제어권을 가지고 명령 수행 -> 일반 명령과 특권 명령 수행 가능
- User mode : 운영체제가 아닌 사용자가 CPU 제어권을 가지고 명령 수행 -> 일반 명령만 수행 가능

- 위 프로세스 X에서 프로그램 명령 실행 중 디스크 입출력 명령을 읽은 경우, 사용자 모드에서는 장치에 접근하는 특권 명령을 수행할 수 없음. 
- 이 때, 운영체제에 System Call을 통해 특권 명령 수행 요청
- 시스템 콜이 커널의 Code 영역으로 보내지도록 프로그램이 인터럽트 라인에 인터럽트 세팅
- CPU가 인터럽트 라인에서 인터럽트를 감지하면, 수행 중인 사용자 프로그램을 멈추고 운영체제에 Control을 넘김
- 하드웨어 모드 비트가 1에서 0으로 세팅되면서 특권 명령을 수행할 수 있게 됨

- ![system call](/sejigner/img/os/interrupt/1.jpg)
> Written with [StackEdit](https://stackedit.io/).
