## 프로세스
- 프로세스는 메인 메모리에 할당되어 실행중인 상태인 프로그램을 말함

- 프로그램은 일반적으로 하드디스크에 저장되어 아무 일도 하지 않지만, 프로세스는 실행하면서 stack pointer, data, text, register 등이 끊임없이 변함

- 즉, 프로그램은 컴파일한 코드와 초기화 전역변수, 문자열과 문자열 상수 등 정적 데이터를 포함하는 정적인 개체인 반면, 프로세스는 아래처럼 메모리 구조를 이루고, 프로그램 카운터(PC), 레지스터처럼 현재 어떤 자원을 사용하는지 관련 정보가 들어 있는 동적인 개체임

![one](/cheewr85/img/OS/four.png)

- 여기서 Stack은 데이터를 일시적으로 저장하는 영역임, 지역변수를 사용하고 변수가 범위 밖으로 이동하면 공간을 해제함, 호출한 함수의 반환 주소, 반환 값, 매개변수 등에 사용하고, 함수를 호출할수록 커지고 반환하면 줄어듬, 힙과 인접한 방향으로 점점 커지고 스택 포인터와 힙 포인터를 만나면 메모리가 소진된 것임

- Heap은 코드 영역과는 별개로 유지되는 자유 영역임, 동적으로 메모리를 할당하려고 프로그램 실행 중 시스템 호출을 사용했다가 해제하는 방법으로 활용함, 프로세스의 공유 라이브러리와 동적으로 적재된 모듈이 서로 공유하는데, 동적 메모리 할당이 발생하면 스택영역 쪽인 위쪽으로 커짐

- Data는 프로그램의 가상 주소 공간임, 전역변수나 정적변수를 저장하거나 할당하고 실행하기 전에 초기화함, 읽기 쓰기가 가능함

- Code는 실행 명령을 포함하는 메모리이거나 목적 파일에 있는 프로그램 영역임, 프로그램을 시작할 때 프로세서가 디스크에서 읽어 실행하는 컴파일한 프로그램을 저장함, 해당 영역을 침범하여 쓰기를 시도하면 오류가 뜨고 종료됨

- 이런 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 자원 영역에 접근할 수 없음, 만약 그런 시도를 한다면 프로세스 간의 통신(IPC)를 사용해야함

---------

### 프로세스 상태
- New는 프로그램이 메인 메모리에 할당된 상태임

- Ready는 할당된 프로그램이 초기화와 같은 작업을 통해 실행되기 위한 모든 준비를 마친 상태이고

- Running은 CPU가 해당 프로세스를 실행하는 것임

- Waiting은 프로세스가 끝나지 않은 시점에서 I/O로 인해 CPU를 사용하지 않고 다른 작업을 하는 것(해당 작업이 끝나면 다시 CPU에 의해 실행되기 위해 ready 상태로 돌아감)

- Terminated는 프로세스가 완전히 종료된 상태임, 그 전이도를 보면 아래와 같음

![one](/cheewr85/img/OS/five.png)

- 기본적으로 프로세스의 상태는 실행 상태와 비실행 상태로 구분할 수 있음, 초기에 운영체제가 프로세스를 생성하면 비실행 상태로 초기화해서 실행을 기다림

- 그리고 실행 중인 프로세스를 종료하거나 인터럽트가 발생하면 비실행 프로세스 중에서 선택한 프로세스를 실행 상태로 바꿈(dispatch), 이때 인터럽트된 프로세스는 비실행 상태가 됨

- 실행 중인 프로세스는 새로운 자원을 할당받으려고 프로세스를 기다리는 비실행 상태로 바뀌기도 함

- 이런 상태 변화를 스케줄러에서 이용하여 관리를 함

- 그리고 실행 상태의 프로세스가 프로세서를 자발적으로 반환하기 전에 할당된 CPU 점유시간이 지나면 이 프로세스는 준비 상태가 됨

- 그리고 프로세스를 실행하다 입출력 명령이 발생하면 대기 상태가 됨

- 대기 상태인 프로세스는 대기 원인을 제거하면 준비 상태로 바뀌고, 디스패처가 준비 상태인 프로세스에 프로세서를 할당하면 다시 실행 상태로 바뀜

- 디스패처는 스케줄러가 선택한 프로세스에 프로세서를 할당함 

- 준비 -> 실행 : dispatch / 실행 -> 준비 : timeout / 실행 -> 대기 : block / 대기 -> 준비 : wakeup

----------

### PCB(Process Control Block)
- PCB는 프로세스에 대한 모든 정보가 모여있는 곳임

- 이 안에는 프로세스의 상태, 프로세스 번호(PID), 해당 프로세스의 Program Counter(PC), Register 값, MMU 정보, CPU 점유시간 등이 포함되어 있음

- PCB는 운영체제 내부의 프로세스를 관리하는 코드 부분에 저장되어 있음

- 이는 CPU는 한 프로세스가 종료될 때까지 수행하는 것이 아닌 여러 프로세스를 중간 중간에 바꿔가면서 수행하기 때문에 수행중인 프로세스를 나갈 때, 이 프로세스의 정보를 어딘가에 저장하고 있어야 다음에 이 프로세스를 수행할 때 이전에 수행한 그 다음부터 이어서 작업을 할 수 있는데 이러한 정보를 저장하는 것이 PCB임

![one](/cheewr85/img/OS/six.png)

---------

### 프로세스 큐
- 프로세스는 수행하면서 상태가 여러 번 변하는데 이에 따라 서비스를 받아야하는 곳이 다름

- 그리고 프로세스는 일반적으로 여러 개가 한 번에 수행되므로 그에 따른 순서가 필요함, 이러한 순서를 대기하는 곳을 큐라고함

![one](/cheewr85/img/OS/seven.png)

- Job Queue는 하드디스크에 있는 프로그램이 실행되기 위해 메인 메모리의 할당 순서를 기다리는 큐임

- Ready Queue는 CPU 점유 순서를 기다리는 큐임

- Device Queue는 I/O를 하기 위한 여러 장치가 있는데 각 장치를 기다리는 큐가 존재함

- 이렇게 여러 큐가 존재하는데, 각 큐 내부에 저장된 실제 데이터는 각 프로세스의 PCB가 저장되어 있음

- 그리고 이러한 순서를 기다리는 공간이 있다면 이 순서를 정해주는 알고리즘이 있어야 하는데 이러한 알고리즘이 스케줄링(Scheduling)임

- 각각 Job Queue의 경우 Job Scheduler, Ready Queue의 경우 CPU Scheduler, Device Queue는 Device Scheduler로 처리가 됨

---------

### 멀티 프로그래밍
- 멀티 프로그래밍은 단일 프로세서(CPU) 환경에서 여러 개의 프로세스가 동시에 실행되는 것을 말함

- 여러 프로세스가 실행되려면 이 프로세스들은 모두 메인 메모리에 존재하고 있어야함

- 여기서 이 때 실제로 동시에 실행되지는 않고 마치 동시에 실행되는 것처럼 보이는 것임

- 여기서 주로 알아볼 사항이 있음

#### Context Switching
- 인터럽트나 시스템 호출 등으로 실행중인 프로세스의 제어를 다른 프로세스에 넘겨 실행 상태가 되도록 하는 것임

- 즉, CPU가 한 프로세스에서 다른 프로세스로 옮겨가는 것을 말하는 것임(결국 한 프로세스가 실행중인 것을 멈추고 다른 프로세스가 실행되는 것)

- 위에서 프로세스 상태에서 스케줄러, 디스패처를 말하였는데 각각의 역할이 있음

- Scheduler(스케줄러)는 CPU Scheduler를 말하는 것이고 CPU가 어느 프로세스를 선택할지 정함

- Dispatcher(디스패처)는 Context Switching이 발생하면 CPU 내부 데이터를 이전 프로세스 데이터에서 새로 시작되는 데이터로 바꿔줌, 즉 현재 CPU 데이터는 이전 프로세스의 PCB에 갱신하고, 새로 시작되는 프로세스의 PCB 데이터를 CPU로 복원해줌

- Context Switching Overhead는 Context Switching이 발생할 때마다, Dispatcher에서 수행하는 작업을 매번 수행해야하며 이 모든 것이 Overhead임, 이런 Context Switching은 매우 자주 발생하는 작업이어서 Overhead를 줄이기 위해서 Dispatcher를 구현하는 코드에 대한 효율을 최대한 높여줘야함

- 여기서 Context Switching은 레지스터 Context 교환, 작업 Context 교환, 쓰레드 Context 교환, 프로세스 Context 교환등이 가능함

---------

## 스레드
- Thread는 프로세스 내에서 실행되는 실행 단위임, 프로세스는 이러한 Thread를 한 개 이상으로 나눌 수 있음

- Thread는 Program Counter, Stack Point 등을 비롯한 Thread 실행 환경 정보(Context 정보), 지역 데이터, Stack을 독립적으로 가지면서 Code, 전역 데이터, Heap을 다른 Thread와 공유함

![one](/cheewr85/img/OS/eight.png)

- 프로세스 하나에 포함된 Thread들은 공동의 목적을 달성하기 위해 병렬로 수행함

- 이를 통해서 사용자 응답성 증가, 프로세스 자원과 메모리 공유가능, 그리고 Process Context Switching보다 Thread Context Switching이 Overhead가 적고 다중 처리로 성능과 효율을 향상할 수 있음

- 현대 시스템 대부분이 다중 Thread 운영체제임, 프로그램 하나를 여러 실행 단위로 쪼개어 실행하는 것, 그리고 커널이 개입하지 않고도 독립적으로 실행할 수 있어서 서버에서 많은 요청을 효과적으로 처리할 수 있음

