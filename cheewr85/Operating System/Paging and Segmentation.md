## 페이지와 세그먼테이션
- 이 기법을 쓰는 이유는 다중 프로그래밍 시스템에서 다수의 프로세스를 수용하기 위해 주기억장치를 동적으로 분할하는 메모리 관리 작업이 필요함

- 즉, 단일 프로그램만 쓰는 것이 아니기 때문에 이를 어떻게 메모리에 적재할 것인지 따져야 하는데 이를 메모리 관리 기술을 생각해서 처리를 하는데 그 중에 페이지와 세그먼테이션을 사용하는 것

-------

## 메모리 관리
- 앞서 말했듯이 프로그램을 어떻게 메모리에 적재할 것인지 판단하는 것인데 페이징과 세그먼테이션뿐 아니라 다른 기법도 존재함

### 연속 메모리 관리
- 프로그램 전체가 하나의 커다란 공간에 연속적으로 할당되어야 하는 방법

- 고정 분할 기법 : 주 기억 장치가 고정된 파티션으로 분할 -> 내부 단편화 발생

- 동적 분할 기법 : 파티션들이 동적 생성되며 자신의 크기와 같은 파티션에 적재 -> 외부 단편화 발생

![one](/cheewr85/img/OS/twentynine.png)

- 이렇게 연속 메모리 관리 기법을 사용하면 단편화 현상이 발생함

- 이 단편화 현상은 기억 장치의 빈 공간 또는 자료가 여러 조각으로 나뉘는 현상을 말함 프로세스들이 메모리에 적재되고 제거되는 일이 반복되면 프로세스들이 차지하는 메모리 틈 사이에 사용하지 못할 만큼의 자유 공간이 늘어나느 것임, 이 단편화는 아래에 2가지로 볼 수 있음

#### 내부 단편화
- 프로세스가 사용하는 메모리 공간에 남는 부분

- 프로세스가 요청한 양보다 더 많은 메모리를 할당할 때 발생하며, 메모리 분할 자유 공간과 프로세스가 사용하는 공간의 크기 차이를 의미함

![one](/cheewr85/img/OS/thirty.png)

#### 외부 단편화
- 메모리 공간 중 사용하지 못하게 되는 부분

- 메모리 할당 및 해제 작업의 반복으로 작은 메모리가 중간 중간 존재할 수 있음, 이렇게 사용하지 않는 메모리가 존재해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황임

- 외부 단편화를 해결하기 위해 압축을 이용하여 프로세스가 사용하는 공간을 한쪽으로 몰 수 있지만, 작업 효율이 좋지는 않음

![one](/cheewr85/img/OS/thirtyone.png)

-------

### 불연속 메모리 관리
- 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법, 단편화 문제를 해결하기 위해 제시된 기법

- 앞서 말한 페이징과 세그먼테이션이 여기에 있고 외부 단편화 해소를 위한 페이징과 내부 단편화 해소를 위한 세그먼테이션으로 나뉨

- 페이지(page) : 작은 고정 사이즈의 프로세스 조각

- 프레임(frame) : 페이지와 크기가 같은 주기억장치 메모리 조각

- 페이지 테이블 : 프로세스의 각 페이지에 해당하는 프레임 위치 관리

- 단편화 : 기억 장치의 빈 공간 또는 자료가 여러 개의 조각으로 나뉘는 현상

- 단순 페이징 : 고정 분할 방법과 유사

- 세그먼트 : 서로 다른 크기를 가지는 논리적인 블록이 연속적인 공간에 배치되어 있는 것

- 고정 크기 : 페이징(Paging)

- 가변 크기 : 세그먼테이션(Segmentation)

#### 페이징(Paging)
- 프로세스를 일정한 크기의 페이지로 분할해서 메모리에 적재하는 방식임

- 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법임

#### 페이징 테이블
![one](/cheewr85/img/OS/thirtytwo.png)

- 물리 메모리는 고정 크기의 프레임으로, 가상 메모리는 고정 크기의 페이지로 분리되어 있음

- 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 매핑되어 저장됨

- 모든 프로세스는 하나의 페이징 테이블을 가지고 있으며, 여기에는 메인 메모리에 적재되어 있는 페이지 번호와 해당 페이지가 위치한 메인 메모리의 시작 주소가 있음

- 이를 통해 하나의 프로세스를 나눈 가상 메모리 페이지들이 각각 실제 메인 메모리의 어디 프레임에 적재되어 있는지 알아낼 수 있음

![one](/cheewr85/img/OS/thirtythree.png)

- 위의 페이징 테이블에서는 P1프로세스의 0번째 페이지가 메인 메모리의 5번째 프레임에 있는 것을 알 수 있음

#### 논리 주소와 페이지 테이블
- 메모리 관리 장치(MMU)에선 가상 주소(논리 주소)를 이용해 실제 데이터가 담겨 있는 주소로 변환을 해주는데 논리 주소는 `<page, offset>`과 같은 형태로 구성되는데 이를 이용해 물리 주소로 변환해 주는 것임

![one](/cheewr85/img/OS/thirtyfour.png)

![one](/cheewr85/img/OS/thirtyfive.png)

#### 페이징의 장단점
- 장점 : 논리 메모리는 물리 메모리에 저장될 때 연속되어 저장될 필요가 없고, 물리 메모리의 남는 프레임에 적절히 배치되기 때문에 외부 단편화가 생기지 않음

- 단점 : 내부 단편화 문제가 발생할 수 있음, 페이지 단위를 작게하면 해결할 수 있지만, 페이지 매핑 과정이 복잡해져 오히려 비효율적임

#### 세그먼테이션(Segmentation)
- 가상 메모리를 서로 크기가 다른 논리적 단위로 분할한 것을 의미함

- 프로세스를 물리적 단위인 페이지가 아닌 논리적 단위인 세그먼트로 분할해서 메모리에 적재하는 방식임

- 세그먼트는 의미가 같지 않는 논리적 내용을 기준으로 프로그램을 분할하기 때문에 크기가 같지 않음

![one](/cheewr85/img/OS/thirtysix.png)

#### 세그먼트 테이블
- 분할 방식을 제외하고 페이징과 세그먼테이션이 동일하기 때문에 매핑 테이블의 동작 방식도 동일함

- 단, 논리 주소의 앞 비트들은 페이징 번호가 아닌 세그먼트 번호가 됨 `<segment, offset>` 형태로 구성되고 세그먼트 번호를 통해 세그먼트의 기준(세그먼트의 시작 물리 주소)와 한계(세그먼트의 길이)를 파악할 수 있음

#### 세그먼테이션의 장단점
- 장점 : 내부 단편화 문제가 해소됨, 보호와 공유 기능을 수행할 수 있음, 프로그램의 중요한 부분과 중요하지 않은 부분을 분리하여 저장할 수 있고 같은 코드 영역은 한 번에 저장할 수 있음

- 단점 : 외부 단편화 문제가 생길 수 있음

--------

### 페이징과 세그먼테이션

#### 단순 페이지
- 각 프로세스는 프레임과 같은 길이를 가진 균등 페이지로 나뉨

- 외부 단편화가 생기지 않음

- 내부 단편화가 존재할 수 있음

#### 단순 세그먼테이션
- 각 프로세스는 여러 세그먼트로 나뉨

- 내부 단편화가 생기지 않음

- 메모리 효율을 개선함

- 동적 분할을 통한 오버헤드가 감소함

- 외부 단편화가 존재할 수 있음

#### 가상 메모리 페이징
- 단순 페이징과 비교해 프로세스 페이지 전부를 로드할 필요가 없음

- 필요한 페이지가 있으면 나중에 자동으로 불러들임

- 외부 단편화가 생기지 않음

- 복잡한 메모리 관리로 오버헤드가 발생할 수 있음

#### 가상 메모리 세그먼테이션
- 필요하지 않은 세그먼트들은 로드되지 않음

- 필요한 세그먼트가 있을 때 나중에 자동으로 불러들임

- 내부 단편화가 생기지 않음

- 복잡한 메모리 관리로 오버헤드가 발생할 수 있음