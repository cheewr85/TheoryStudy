## 메모리란
- 메모리란 주소를 통해 접근하는 객체로, 메인 메모리는 주기억장치를 의미함

- 따로 언급이 없으면 메모리는 메인 메모리(RAM)를 의미함

- 컴퓨터에서 메모리는 중요한 작업 공간임, 프로세스는 CPU에서 바로 계산을 할 수 없고, 메모리에 적재한 후에 실행할 수 있음

- 프로그램이 프로세서(CPU)에 할당되려면(프로그램이 프로세스가 되어 실행하려면) 메모리에 적재되어야 함

### 메모리 = 주소로 인덱싱하는 커다란 배열
- 컴퓨터를 부팅하면 비어있던 메모리에 운영체제, 사용자 프로그램이 배열 원소처럼 메모리에 채워짐, 이들은 CPU를 점유할 기회를 노림

### 컴파일러
- CPU는 메모리에 채워진 프로그램 코드를 곧장 읽을 수 없고, 컴퓨터가 이해할 수 있도록 숫자로 바꿔줘야함

- 컴파일러는 코드를 숫자로 바꾸어주고 코드의 주소를 결정해줌

![one](/cheewr85/img/OS/fourtyfour.png)

---------

### 주소 바인딩
- `Symbolic Address -> Logical Address -> Physical Address`의 과정을 거침

- 주소 바인딩은 프로그램이 물리적인 메모리 어느 부분에 적재될지 결정하는 것임

- 논리주소만으로는 실제 메모리의 주소를 알 수 없기 때문에 논리주소를 물리적 메모리로 연결시키는 작업이 필요함

#### Symbolic Address
- 변수(Variable)는 데이터를 저장하기 위해 프로그램에 의해 이름을 할당받은 메모리 공간임

- 변수와 값 지정시, 변수를 하드웨어의 어디에 저장할지 결정하지는 않음 그 변수를 CPU가 어떻게 인식할지도 정하지 않고 그저 변수의 이름을 통해서 그 값에 접근할 수 있음

- 그래서 메소드나 변수가 이에 해당함

#### Logical Address
- 각 프로세스마다 가지는 주소로, 0번지부터 시작함, 논리주소는 중복되며 가상주소라고도 부름

- 논리주소가 중복될 때 메모리가 이를 구별하기 위해서 논리주소에 하나의 주소값을 추가함, 이 주소값은 물리주소임

#### Physical Address
- 물리적인 메모리 주소로 실제 하드웨어에 올라가는 위치임

- 중복되는 논리주소에 하나의 주소값을 추가하여, 프로세스의 독립된 물리주소가 생김

![one](/cheewr85/img/OS/fourtyfive.png)

#### 주소 바인딩을 하는 이유
- CPU는 논리주소만으로 물리 메모리에 올라와 있는 프로세스의 정보를 읽음

- CPU는 현재 활동중인 프로세스의 내부의 주소만 알면 됨, 어떤 프로세스인지 알 필요가 없음

- 프로그램을 물리 메모리의 어느 부분에 적재할지 결정해야하므로 물리주소도 필요함

### 주소 바인딩의 세가지 방식

#### 컴파일 타임 바인딩
- 컴파일 할 때 물리적 메모리 주소가 결정됨

- 물리적인 메모리가 많이 비었어도 변경할 수 없는 비효율적인 방법임, 프로그램의 물리적 주소를 변경하고 싶으면 다시 컴파일 해야함

#### 로드 타임 바인딩
- 프로그램의 실행이 시작될 때 물리적 주소가 결정됨

- 메모리 주소를 부여받고 프로그램이 종료될 때까지 물리주소가 고정됨, 컴파일러가 재배치할 수 있음

#### 실행 시간 바인딩(Run time)
- 프로그램이 실행한 후에도 물리적 주소를 변경할 수 있음

- CPU가 주소를 참조할 때마다 물리적 메모리의 어느 위치에 존재하는지 주소 매핑 테이블을 이용해 주소 바인딩을 점검함

- MMU가 필요함

----------

### MMU(Memory Management Unit)
- 논리주소를 물리주소로 매핑해주는 하드웨어임

- 두 레지스터가 존재함

- relocation register : 접근할 물리적 메모리 주소의 최소값(시작 주소)

- limit register : 현재 CPU에서 수행중인 프로세스의 논리적 주소의 최대값(프로세스의 크기)

- CPU가 범위를 벗어나는 주소를 요청할 경우 오류를 알림

![one](/cheewr85/img/OS/fourtysix.png)

-------

### 가상 메모리
- 프로그램의 일부만 메모리에 적재되어도 실행가능한 환경에서는 우선 일부만 메모리에 적재하고 나머지는 저장공간(디스크)에 빼둔 후, 필요한 부분을 점차 메모리에 적재함

- 사용자에게 실제보다 큰 용량의 메모리를 제공하는 효과를 줌

- 이처럼 디스크를 마치 메모리처럼 사용하는 것을 가상 메모리라고 함

#### 스와핑(SWAPPING)
- 프로세스를 일시적으로 메모리에서 하드디스크에 있는 SWAP 공간으로 쫓아내는 기법임

- 스왑 아웃 : 메인 메모리의 프로세스에서 일정 페이지를 잘라서 SWAP 공간으로 가져가는 것을 말함

- 스왑 인 : SWAP 공간에 옮겨 두었던 프로세스의 페이지를 다시 메인 메모리로 가져오는 것을 말함

- 프로세스를 저장공간에 빼놨다가 메모리에 올려 다시 실행했다가 이런 식으로 프로세스를 교체함

- 시간비용이 많이 듬(Swapping 할 프로세스를 고르기 위한 프로세스 중요도 계산, 하드디스크까지 전체 프로세스 스왑)

![one](/cheewr85/img/OS/fourtyseven.png)

#### 가상 메모리와 성능
- 가상 메모리와 메모리를 스왑하는 비용 때문에 성능 저하가 발생함

- 따라서 스와핑이 발생하지 않도록 메모리 여유율을 유지하는 것이 성능에 중요함

- 메모리 사용율이 100%이거나 지속적으로 스왑 아웃이 발생하면 메모리 부족임

--------

### 메모리 분할
- 메모리 분할의 경우 여러 프로세스를 동시 적재하는 다중 프로그래밍을 하기 위해 메모리 분할이 필요하므로 사용함

- 세부적인 내용은 Paging and Segmentation에서 다뤘음

- 동적 분할의 할당 정책만 좀 더 알아볼 것임

#### 동적분할의 할당정책
- 최적 적합(Best-fit) 할당

    - 필요한 공간과 가장 근접한 크기의 빈 공간을 선택함

    - 할당하고 남은 아주 작은 빈 공간이 또 생김

- 최악 적합(Worst-fit) 할당

    - 빈 공간 중 가장 큰 공간을 할당함

- 최초 적합(First-fit) 할당

    - 필요한 공간보다 크면 무조건 할당함

    - 요구사항을 만족하는 빈 공간을 발견하자마자 할당함

    - 검색 부담을 줄임

- 순차 적합(Next-fit) 할당

    - 최초 적합 할당은 항상 메모리의 처음부터 검색하므로 작은 분할이 많아 발생할 수 있음

    - 그래서 순차 적합 할당은 이전에 할당된 공간을 기록해두었다가, 바로 그 다음 공간부터 검색함


- 이외에도 메모리 관리 전략에 Paging, Segmentation 등 그리고 그에 따른 페이지 교체 알고리즘이 있지만 이전에 봤기 때문에 넘어감

---------

### 캐시의 지역성

- 이 부분 역시 캐시 메모리도 존재하기 때문에 쓴 부분인데 Computer System에서 Cache Memory에서 좀 더 상세하게 다룸